#!/usr/bin/python

import sys
from PyQt5 import QtCore, QtGui, QtWidgets,uic
from sympy import mod_inverse	#for optimized mod_inverse
import sys

#Import code generated by pyqt5 designer 
#pyuic5 *.ui -o *.py
from Ciphers import Ui_MainWindow 

class Ui(QtWidgets.QMainWindow):
	global firstRun # Described where I use it
	firstRun = True

	def __init__(self):
		#Initiates the UI designed in Qt5 Designer
		super(Ui, self).__init__()
		self.ui = Ui_MainWindow()
		self.ui.setupUi(self)
		self.show()			

		# Change the text in the CipherText Field when PlainText/Key/Encryption Mode is changed
		self.ui.codewordInput.textChanged.connect(self.Encrypt)
		self.ui.keyInput.textChanged.connect(self.Encrypt)
		self.ui.decryptBool.toggled.connect(self.Encrypt)
		self.ui.encryptionCipher.currentIndexChanged.connect(self.Encrypt)

		# Initates the log and moves the CipherText to the PlainText field
		self.ui.encodeButton.clicked.connect(self.Btn)
		


	def Btn(self):
		global firstRun

		word = self.ui.codewordInput.toPlainText() #Gets PlainText as a String
		key = self.ui.keyInput.toPlainText() #Gets Key as a String
		encryptionType = str(self.ui.encryptionCipher.currentText()) #Gets Encryption Type as a String
		output = self.ui.outputInput.toPlainText() #Gets CipherText as a String

	
		if firstRun: 
			#Creates or overwrites old Log if the button was pressed for the first time
			log = open("log.txt","w+",encoding='utf-8') 
			log.write('Codeword:'+str(word)+' Cipher:'+str(encryptionType)+' Key :\''+str(key)+'\' --->  \''+str(output)+'\'')
			firstRun = False
		else:
			# Adds the next sequential cipher to the Log
			log = open("log.txt","a",encoding='utf-8') 
			log.write(('------> Cipher:'+str(encryptionType)+' Key\'' +str(key)+'\' ---> \''+str(output)+'\''))

		log.close() 

		self.ui.codewordInput.setText(output)
		self.Encrypt()

		#Copies the output to system clipboard if the user want to	
		if self.ui.copyBool.isChecked():
			#stolen from stackoverflow.com/questions/1073550/pyqt-clipboard-doesnt-copy-to-system-clipboard

			clipboard = QtWidgets.QApplication.clipboard()
			clipboard.setText(output) 
			event = QtCore.QEvent(QtCore.QEvent.Clipboard)
			app.sendEvent(clipboard, event)

	def Encrypt(self):

		word = self.ui.codewordInput.toPlainText()
		key = self.ui.keyInput.toPlainText()

		EncryptMode = False if self.ui.decryptBool.isChecked() else True #Check if the user want to encrypt or decrypt

		if self.ui.encryptionCipher.currentIndex() == 0 and key.isnumeric(): #Index 0 is Ceaser shift
			output = self.ceaserShift(word,key,EncryptMode)
			self.ui.outputInput.setText(output)

		elif self.ui.encryptionCipher.currentIndex() == 1 and key.isalpha(): #Index 1 is Vigenere Cipher
			output = self.Vigenere(key,EncryptMode)
			self.ui.outputInput.setText(output)

		elif self.ui.encryptionCipher.currentIndex() == 2 and key.isnumeric(): #Index 2 is Multiplicative Cipher
			output = self.Multipicative(word,key,EncryptMode)
			self.ui.outputInput.setText(output)

		elif self.ui.encryptionCipher.currentIndex() == 3 and key != '': #Index 3 is Affine Cipher
			try: # A little hacky coding
				mulKey,addKey = tuple(key.split(","))
				output = self.Affine(word,mulKey,addKey,EncryptMode)
				self.ui.outputInput.setText(output)
			except:
				print('INVALID FORMAT')

		elif self.ui.encryptionCipher.currentIndex() == 4 and key != '': #Index 4 is Rail Fence Cipher
			output = self.railFence(word,key,EncryptMode)
			self.ui.outputInput.setText(output)

	def storeCase(self,Word):
		#Just returns a List containing the original case of PlainText
		Lst = []

		for i in range(len(Word)):
			if Word[i].isupper():
				Lst.append(True)
			else:
				Lst.append(False)
		return Lst

	def restoreCase(self,Word,codeCase):
		#Restores the case of the CipherText
		newWord = ""

		for i in range(len(Word)):
			if codeCase[i]:
				newWord =newWord + Word[i].upper()
			else:
				newWord =newWord + Word[i]
		return(newWord)

	def ceaserShift(self,word,key,EncryptMode):
		key = int(key) if EncryptMode else -int(key) # Key is subtracted while Decrypting
		codeCase = self.storeCase(word)
		word = word.lower()
		outputASCII = []	#Empty list to store the positional values of characters

		for letter in word:
			if letter.isalpha():
				outputASCII.append(ord(letter)-97) #Since the plaintext is in lowercase we just subtract 97 which is the ordinal value of 'a'
			else:
				outputASCII.append(ord(letter)) #Special Characters are ignored

		for i in range(len(outputASCII)):
			if outputASCII[i] < 0 or outputASCII[i] > 25: #Special Characters are ignored
				continue
			outputASCII[i] =  (outputASCII[i] + int(key))%26 + 97
			if outputASCII[i] < 0: # Can happen during decryption
				outputASCII[i] = 26 - outputASCII[i] + 97

		Output =''.join(chr(i) for i in outputASCII) #Essentially the same as Output = Output + chr(i) inside a for loop, but faster and easier to understand
		Output = self.restoreCase(Output,codeCase)

		return Output

	def Vigenere(self,key,EncryptMode):
		word =  self.ui.codewordInput.toPlainText()
		codeCase = self.storeCase(word)
		word = word.lower()
		key = key.lower()
		output = ""
		Blanks = 0
		while(len(key)<len(word)):	#We just need the key to be longer than the plaintext
			key = key + key


		for i in range(len(word)):
			if word[i].isalpha():
				if EncryptMode:
					ciph = (ord(word[i])+ord(key[i-Blanks])-194)%26 # 97+97 = 194 
				else:
					ciph = ((ord(word[i]) - ord(key[i]) + 26) % 26)
					
				output = output + chr(ciph+97)
			else:
				output += word[i]
				Blanks = Blanks + 1

		output = self.restoreCase(output,codeCase)
		return output

	def Multipicative(self,word,key,EncryptMode): 
		# Just breaks when mod inverse doesn't exist
		key = int(key) if EncryptMode == 1 else mod_inverse(int(key),26) 
		codeCase = self.storeCase(word)
		word = word.lower()
		outputASCII = []

		for letter in word:
			if letter.isalpha():
				outputASCII.append(ord(letter)-97)
			else:
				outputASCII.append(ord(letter))

		for i in range(len(outputASCII)):
			if outputASCII[i] < 0 or outputASCII[i] > 25:
				continue
			try:
					outputASCII[i] =  int((outputASCII[i] * int(key))%26) + 97
			except:
					return 'Key doesn\'t have a mod inverse'

		output =''.join(chr(i) for i in outputASCII)
		output = self.restoreCase(output,codeCase)

		return output

	def Affine(self,word,mulKey,addKey,EncryptMode):
		# Just breaks when mod inverse doesn't exist
		codeCase = self.storeCase(word)
		word = word.lower()
		outputASCII = []
		mulKey = int(mulKey)
		addKey = int(addKey)

		for letter in word:
			if letter.isalpha():
				outputASCII.append(ord(letter)-97)
			else:
				outputASCII.append(ord(letter))

		for i in range(len(outputASCII)):
			if outputASCII[i] < 0 or outputASCII[i] > 25:
				continue
			if EncryptMode:
				outputASCII[i] =  ((outputASCII[i] * int(mulKey))+addKey)%26 + 97
			else:
				try:
					outputASCII[i] = ((outputASCII[i] -	addKey) * int((mod_inverse(mulKey,26))))%26 + 97
				except:
					return 'Key doesn\'t have a mod inverse'
		output =''.join(chr(i) for i in outputASCII)
		output = self.restoreCase(output,codeCase)

		return output

	def railFence(self,word,key,EncryptMode):
		#Adapted from https://www.geeksforgeeks.org/rail-fence-cipher-encryption-decryption/

		key = int(key)
		rail = [['' for i in range(len(word))] for ii in range(key)] #initate empty Grid
		dirDown = False
		row, col = 0, 0
		output = []
		index = 0	

		if EncryptMode:  
			for i in range(len(word)):
				if (row == 0) or (row == key - 1): 
					dirDown = not dirDown 
				rail[row][col] = word[i] 
				col += 1
				if dirDown: 
					row += 1
				else: 
					row -= 1
			output = [] 
			for i in range(key): 
				for j in range(len(word)): 
					if rail[i][j] != '': 
						output.append(rail[i][j]) 
			return("" . join(output)) 

		else:

			for i in range(len(word)): 
				if row == 0: 
					dirDown = True
				if row == key - 1: 
					dirDown = False
				rail[row][col] = '*'
				col += 1
				if dirDown: 
					row += 1
				else: 
					row -= 1

			for i in range(key): 
				for j in range(len(word)): 
					if (rail[i][j] == '*' and index < len(word)): 
						rail[i][j] = word[index] 
						index += 1

			for i in range(len(word)): 
				if row == 0: 
					dirDown = True
				if row == key-1: 
					dirDown = False
				if (rail[row][col] != '*'): 
					output.append(rail[row][col]) 
					col += 1
				if dirDown: 
					row += 1
				else: 
					row -= 1
			return("".join(output))


#to make the PyQt5 window
app = QtWidgets.QApplication(sys.argv) 
window = Ui()
app.exec_()